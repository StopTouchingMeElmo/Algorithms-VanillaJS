//Операторы Async/await - это синтаксический сахар, который позволяет удобно программировать асинхронность.
//Внутри все те же промисы.

//Чтобы использовать оператор await, который обрабатывает промис и ждет его завершения, нужно у РОДИТЕЛЬСКОЙ функции использовать
//префикс async.
//далее мы используем оператор await перед промисом,
//и тот результат, который попадает в метод then(при работе с промисами) мы можем просто синхронно получить в отдельную переменную.
//Что позволяет избавиться от callback'ов, что делает код более читаемым и компактным.


//Наглядный пример реализации одинакового функционала через обычные промисы и через async/await:

//Реализуем функцию задержки через промис, более удобную форму, чем setTimeout
const delay = ms => {
    return new Promise(resolve => setTimeout(() => resolve(), ms))
}

//delay(5000).then(() => console.log('5sec'))

//Задача:
//Делаем асинхронный запрос на сервер и получаем данные, добавляем к этому искусственную задержку,
//чтобы построить цепочку из промисов.

//Для эмитации работы с сервером используем сервис https://jsonplaceholder.typicode.com/
//Fake Online REST API for Testing and Prototyping
const url = 'https://jsonplaceholder.typicode.com/todos'

// 1. Через промисы:
// Для того, чтобы сделать запрос на сервер через промисы мы можем воспользоваться нативной функцией браузера fetch.
// fetch это некий аналог ajax'а, который делает асинхронный запрос и возвращает нам промис.
// Далее мы обращаемся к методу then, в котором получаем некий response от полученного с сервера промиса,
// Далее, чтобы получить json, который прилетает с сервера, мы у объекта response должны вызвать метод json (api метода fetch).
function fetchTodos() {
    console.log('Fetch Todo started...')
    return delay(3000) //(1)
        .then(() => fetch(url))
        .then(response => response.json())
}
fetchTodos() // вызываем функцию fetchTodos(), которая возвращает промис, а значит доступен метод then
    .then((data) => console.log('Data:', data))
    .catch(e => console.error(e))

// 2. Через async/await
// Те функции, которые внутри применяют оператор await должны быть асинхронными (async). Речь о верхнеуровневой функции.
async function fetchAsyncTodos() {
    console.log('Fetch Async Todo started...')
    await delay(4000) // равносильно обработке промиса с последующим then(1)
    // пока промис delay не будет выполнен (resolve) мы не перейдем к следующей строчке. Эту задачу выполняет оператор await.
    const response2 = await fetch(url) // в первом варианте объект response(как результат работы оператора await и метода fetch) попадал в метод then, тут мы кладем его в переменную.
    const data2 = await response2.json() // метод response2.json() так же возвращает нам промис
    console.log('Data Async:', data2)
}
fetchAsyncTodos()

//т.о получается лаконичная и понятная запись, почти как программирование синхронного кода, благодаря оператору await,
//который позволяет не переходит к следующей строке, пока текущая строка с промисом не будет выполнена.

//Чтобы обрабатывать ошибки, используются ключевые слова try/catch. В блок try мы помещаем код с оператором await
//try{

//}.catch(e){

//}

async function fetchAsyncTodos2() {
    console.log('Fetch Async Try Todo started...')
    try {
        await delay(4000)
        const response2 = await fetch(url)
        const data2 = await response2.json()
        console.log('Data Async Try:', data2)
    } catch (e) { //если в блоке try произошла ошибка, она будет отловлена и выведена
        console.error(e)
    } finally { //блок finally также присутствует, который выполнится в любом случае, даже если произошла ошибка
        console.log('Will be done anyway')
    }
}
fetchAsyncTodos2()

// Изначально в JS все было построено на callback'ах, подход async/await нам позволяет использовать транспайлер Babel,
// который оборачивает наш код в те же промисы внутри async функции. И обеспечивает обратную совместимость версий JS для использования
// старыми стандартами языка.

// Как следствие асинхронная функция (async function) всегда возвращает промис.
// А значит мы можем использовать метод then у функции fetchAsyncTodos2 и этот then будет выполнен только тогда, когда будет выполнен
// последний оператор await внутри функции fetchAsyncTodos2.
// fetchAsyncTodos2().then()